# 객체 지향 프로그래밍

- 컴퓨터 프로그래밍 패러다임 중 하나 이다.
- 데이터와 그 데이터를 처리할 메소드를 한데 묶어 객체들을 만들고, 이들을 조립하는 것을 목표로 한 언어들을 말한다.
- 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나, "객체"들의 모임으로 파악하고자 하는 것.
<br>
<b>
<center>
"절차" 대신 "데이터"를 중심으로 생각하자
</center>
</b>

- [OOP 출현 배경](./OOP(object-oriented_programming)_1)
<br><br>

## 특징
<br>

1. 추상화 : 외부 인터페이스(규약)만 제공하고 객체 내부를 숨겨서 동작 방법은 모르더라도 결과는 내보낸다.
    - 복잡한 것은 숨기고, 필요한 것만 드러낸다.<br>

2. 캡슐화 : 객체 내부에 필요한 데이터 등을 묶어서 한번에 관리할 수 있게 해준다.
    - 변수와 함수를 하나의 단위로 묶는다.
    - 세부 구현을 외부로 드러나지 않도록 내부에 감추어 정보를 은닉한다.<br>

3. 상속성 : 부모 객체를 상속받아 사용자가 원하는 대로 추가 기능을 붙이거나 약간의 수정을 가한 객체를 만들 수 있다.
    - 코드의 재사용성을 높이고, 기능을 확장한다.<br>

4. 다형성 : 메소드명은 같더라도 매개변수의 개수, 매개변수의 자료형, 반환하는 값의 자료형에 따라 다른 메소드가 실행될 수 있다.
    - 서로 다른 클래스에 속해있는 객체들이 동일한 명령(코드)에 대해 다른 결과 만든다.<br>
<br><br>

## 객체 _Object
<br>

- 클래스에서 정의한 것을 토대로 메모리에 할당된 모음
    - == 속성(property)과 행동(method)으로 구성된 모음

- 특정 class를 이용하여 객체를 생성하면, <br>
  class 에서 정의한 속성에 접근하여 data를 다룰 수 있고, <br>
  행동에 접근하여 미리 정의된 동작을 수행할 수 있다.<br>

- 예시 <br>
```
(python)
class Fruit(today):
    def __init__(self):
        self.harvest_day = today
        self.rotten_day = today + 15
    
    def can_eat_day():
        return self.rotten_day - 1

banana = Fruit(1)
```

- banana에 할당된 객체 내 존재하는 속성에 접근 : `banana.rotten_day`
- banana에 할당된 객체 내 존재하는 메서드에 접근 : `banana.can_eat_day()`
<br><br>

#### 클래스와 객체와 인스턴스

- 하나의 객체는 "특정 타입"의 인스턴스 이다.
    - 위의 `banana`는 `Fruit` 클래스에 의해 할당된 객체이다.
    - 위의 `banana`는 `Fruit` 클래스의 인스턴스이다.
    - `banana` 객체는 클래스의 인스턴스 이다.

- 엄격하게 객체와 인스턴스를 나누는 것은 어렵고, 굳이 말하자면 개념적으로 차이가 있다.
    - 객체는 "실체"에 초점을 두고, <br>
      인스턴스는 "관계"에 초점을 둔다.


<br><br><hr><br>

# 좀 더 이해하기 쉽게 구문으로 작성

OOP의 동작 방식을 예시를 들어서 설명해 보았습니다.<br>
<br>

## 개요
<br>

python 과 java, 일부 c++에 존재하는 내장함수 또한 모두 객체로 이루어져 있어요.<br>
python의 `list()` 함수의 그 내부 동작 방식을 예시로 들어볼게요.<br>
<br>

컴퓨터에서의 배열은 변수에 그 배열의 메모리 시작 주소를 담고, <br>
그 첫 주소에서 자료형이 차지하는 메모리의 크기만큼 주소값을 더해주면서 순회를 하게 됩니다.<br>
<br>

하지만 python의 `list` 함수는 첫 주소를 어떻게 가져오는지,<br>
배열 내부의 자료형은 무엇이 담길 것인지에 대한 명령어 하나 없이 배열을 그냥 만들어 줘요.<br>
위의 주소값을 더해주면서 순회를 하는 것도 또한 따로 함수를 정의해줘야 쓸 수 있는데,<br>
저희는 배열 앞에 in을 써서 순회가 그냥 가능해요.<br>
<br><br>

## 거시->미시
<br>

python의 내장함수를 참조하면 python 내장 class(혹은 ~/module/class)가 나오고,<br>
class 내부에는 저희가 객체를 만들게 되면 어떤 `property들`과 `field들`을 사용할 수 있는지가 정의되어 있어요.<br>
<br>

좀 더 deep 하게 들어가면, 메서드 동작 방식을 더 깊게 들어가면 c언어가 나와요.<br>

1. 데이터 타입을 어떻게 처리할 것인지
2. 그 배열의 첫 주소를 어떻게 담아줄 것인지
3. 첫 주소를 담아주는 변수의 주소값은 어떻게 처리할 것인지
4. 기타 등등

한 method를 분해해 보면 위 목록들에 대한 명령어의 집합이 작성되어 있어요.<br>
<br>

#### (참고)
<br>

저희가 똑같은 로직이더라도 직접 작성하는 것 보다 module을 이용하면 더 빠른 이유입니다.<br>
용도가 다른 클래스에서 생성한 객체를 이용하여 저희가 원하는대로 사용하는 것이 아닌,<br>
그 용도에 맞게 `methods`와 `fields`가 정의되어 있으니 훨씬 빠른 것이지요.<br>
<br><br>

## 미시 -> 거시
<br>

명령어의 집합 모여 메서드와 변수로 정의되고, <br>
이 method들과 field들이 모여 하나의 class를 이루고, <br>
이 class들이 모여 하나의 module을 이루게 됩니다. <br>
즉, class는 "객체를 만들기 위한 명령어의 집합" 이에요. <br>
<br><br>

## 예시
<br>

저희가 해당 class(혹은 그 class 내부의 method)를 호출하여 이용하여 "객체"를 만들게 되는거에요.<br>
<br>

`list()` 메서드의 반환값("객체"의 첫 주소)을 담은 변수 `my_list = list()`를 선언하면, `my_list`는 `list 상위 클래스`에 종속(instance화)되게 되고,
그 class에서 사용할 수 있는 property (ex- `my_list.append()`)들과 배열(의 주소값)이 담긴 객체가 생성, 해당 속성들을 사용할 수 있게 되는거에요.
이 `my_list`를 "객체"라고 볼 수 있는거죠.<br>
<br>

#### 정리
그렇기에 `my_list` 또한 저희가 만든 객체의 "주소값"이 들어가 있습니다.<br>
`my_list`는 배열이 아니라, `list`의 상위 클래스에 의해 만들어진 "객체"의 첫 주소값 이고,<br>
그 내부에 우리가 `my_list`를 호출할 시 만든 배열의 첫 주소값으로 연결되게끔 동작이 정의가 된 것이지요.<br>
<br>


"객체 지향 언어의 모든 동작은 객체에 의한 것"의 괴리감이 상당히 힘들었어서 저도 찾아봤어가지고...
혹시 도움될까 하여 들고와봅니당..

> 출처
[DOCS_Python](https://docs.python.org/3/tutorial/classes.html)