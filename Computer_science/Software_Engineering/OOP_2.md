# 좀 더 이해하기 쉽게 구문으로 작성

OOP의 동작 방식을 예시를 들어서 설명해 보았습니다.<br>
<br>

## 개요
<br>

python 과 java, 일부 c++에 존재하는 내장함수 또한 모두 객체로 이루어져 있어요.<br>
python의 `list()` 함수의 그 내부 동작 방식을 예시로 들어볼게요.<br>
<br>

컴퓨터에서의 배열은 변수에 그 배열의 메모리 시작 주소를 담고, <br>
그 첫 주소에서 자료형이 차지하는 메모리의 크기만큼 주소값을 더해주면서 순회를 하게 됩니다.<br>
<br>

하지만 python의 `list` 함수는 첫 주소를 어떻게 가져오는지,<br>
배열 내부의 자료형은 무엇이 담길 것인지에 대한 명령어 하나 없이 배열을 그냥 만들어 줘요.<br>
위의 주소값을 더해주면서 순회를 하는 것도 또한 따로 함수를 정의해줘야 쓸 수 있는데,<br>
저희는 배열 앞에 in을 써서 순회가 그냥 가능해요.<br>
<br><br>

## 거시->미시
<br>

python의 내장함수를 참조하면 pyhton 내장 class(혹은 ~/module/class)가 나오고,<br>
class 내부에는 저희가 객체를 만들게 되면 어떤 `property들`과 `field들`을 사용할 수 있는지가 정의되어 있어요.<br>
<br>

### 좀 더 deep 하게 들어가면...
<br>

메서드 동작 방식을 더 깊게 들어가면 c언어가 나와요.<br>

1. 데이터 타입을 어떻게 처리할 것인지
2. 그 배열의 첫 주소를 어떻게 담아줄 것인지
3. 첫 주소를 담아주는 변수의 주소값은 어떻게 처리할 것인지
4. 기타 등등

한 `list` 배열 생성에 대한 method를 분해해 보면 위 목록들에 대한 명령어의 집합이 작성되어 있어요.<br>
<br>

#### (참고)
<br>

저희가 똑같은 로직이더라도 직접 작성하는 것 보다 module을 이용하면 더 빠른 이유입니다.<br>
용도가 다른 클래스에서 생성한 객체를 이용하여 저희가 원하는대로 사용하는 것이 아닌,<br>
그 용도에 맞게 `methods`와 `fields`가 정의되어 있으니 훨씬 빠른 것이지요.<br>
<br><br>

## 미시 -> 거시
<br>

명령어의 집합 모여 메서드와 변수로 정의되고, <br>
이 method들과 field들이 모여 하나의 class를 이루고, <br>
이 class들이 모여 하나의 module을 이루게 됩니다. <br>
즉, class는 "객체를 만들기 위한 명령어의 집합" 이에요. <br>
<br><br>

## 예시
<br>

저희가 해당 class(혹은 그 class 내부의 method)를 호출하여 이용하여 "객체"를 만들게 되는거에요.<br>
<br>

`list()` 메서드의 반환값("객체"의 첫 주소)을 담은 변수 `my_list = list()`를 선언하면,<br>
`my_list`는 `list 상위 클래스`에 종속(instance화)되게 되고,<br>
그 class에서 사용할 수 있는 property (ex- `my_list.append()`)들과 배열(의 주소값)이 담긴 객체가 생성,<br>
 해당 속성들을 사용할 수 있게 되는거에요. 이 `my_list`를 "객체"라고 볼 수 있는거죠.<br>
<br>

#### 정리
그렇기에 `my_list` 또한 저희가 만든 객체의 "주소값"이 들어가 있습니다.<br>
`my_list`는 배열이 아니라, `list`의 상위 클래스에 의해 만들어진 "객체"의 첫 주소값 이고,<br>
그 내부에 우리가 `my_list`를 호출할 시 만든 배열의 첫 주소값으로 연결되게끔 동작이 정의가 된 것이지요.<br>
<br>
